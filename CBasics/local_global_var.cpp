#include <stdio.h>

// 변수의 종류
// 1. 지역변수 : 함수가 호출될 때 사용하는, 함수들이 사용하는 메모리 영역
// 2. 전역변수 : Data 영역 사용
// 3. 정적 변수(static) : Data 영역 사용
// 4. 외부 변수(extern) : Data 영역 사용

// 메모리 영역
// 1. 스택 영역
// 2. 데이터 영역 : 프로그램이 실행될 때, main 함수가 호출되면서 Data 영역이 프로그램 시작과 동시에 생성됨
// 3. 읽기 전용(코드, ROM)
// 4. 힙 영역


// 전역변수
int g_i = 0;  // Data 영역

// 다른 cpp파일에 전역변수를 선언하면 컴파일 단계에서는 문제가없음.
// 컴파일은 각자 파일 단위로 해서 목적파일 .obj가 생성되는데 각 파일 단위로 봤을때는 문법적으로 문제가 없다. 
// 최종적으로 프로그램을 만들어 내는 전체 과정 속에서 각각 파일 단위로 컴파일 된걸 함쳐서 링킹라는 과정을 하면서
// 서로 연결은 하는데 전역변수가 같은 이름으로 여러개 있으면 문제가 됨. 


// Data 영역 특징
// 프로그램 시작 시 생성
// 프로그램 종료 시 해제 
// 프로그램이 실행되는 내내 계속 존재!!

#include "func.h" // func.h 파일에 int Add(int a, int b); 선언 되어있음!
	          // func.h 파일을 참조하면 func.cpp에 구현되어있는 목록 다 사용 가능! 

void Test();  // 함수를 앞에다 선언 후 나중 구현할 수도 있다!!

//void Test()  // Test 함수의 반환 타입이 없을 때 void 사용
//{
//	int i = 0;
//	++i;
//
//	++g_i; // 전역번수 : 3
//}	       // 함수의 호출과 종료에 상관없이 데이터영역에는 값을 유지(프로그램이 실행되는 동안)

int main()
{

	Test();	 // stack 반환 후 해제!!
	Test();  // 함수 안에 선언되는 지역변수들은 해당 함수가 종료되면 해제되고 다시 호출되어야 새롭게 생김
	Test();

	g_i = 0; // Data 영역에 있기 때문에 수행 가능!!

	int data = Add(10, 20); // func.cpp에 구현되어있음

	// 분할 구현
	// 헤더와 파일을 분리하는 이유?


	return 0;
}


void Test()  // Test 함수의 반환 타입이 없을 때 void 사용
{
	int i = 0;
	++i;

	++g_i; // 전역번수 : 3
}	       // 함수의 호출과 종료에 상관없이 데이터영역에는 값을 유지(프로그램이 실행되는 동안)



// 헤더 파일을 분할해서 구현하는 이유
// 헤더에서는 함수가 있다고 선언을 해주고 func.cpp(다른소스파일)에서는 기능을 구현해주고
// main.cpp()에서는 기능을 사용한다.
// 이렇게 하면 나중에 코드의 가독성이 좋아진다. 또 코드를 손쉽게 관리할 수 있다.
// 헤더와 파일 단위로 관련있는 기능들을 묶어서 관리를 쉽게하고,
// 코드를 재사용하기 편하게하려고 헤더랑 파일을 분할을 해서 선언과 정의를 분리시킴
// 만약에 main() 파일에 모든 코드를 쓰면 코드가 말도 안되게 많아진다

// 헤더랑 파일을 분할해서 구현하면 link 하는 과정에서 속도저하가 일어나고 컴파일도 오래걸림!!

// 분활구현을 하면 전역변수를 쓰기 애매해진다.