#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <mbstring.h>
#include <wchar.h>

// 메모리 영역
// 1. 스택
// 2. 힙
// 3. 데이터
// 4. ROM(코드)

int main()
{
	// 문자
	// char(1), wchar(2)

	// 0 ~ 255 : utf-8 경우, 7비트 밖에 쓸 수가없다.
	// 실제로 1바이트로 맵핑 시킬수 있는 문자가 127개 밖에 안됨

	char c = 'a';			
	wchar_t wc = L'a';		// 2바이트로 문자를 넣을때 'L'을 붙임

	char szChar[10] = "adcdef";			// 문자열에 적혀있는 데이터를 그대로 배열로 옮겨 오겠다.

	wchar_t szWChar[10] = L"abcdef";	// 2바이트 문자, { 97, 98 ,99, 100, 101, 102, } 해도 상관 없음!
	const wchar_t* pChar = L"abcdef";	// 문자열의 시작주소를 포인터 변수로 받아왔다. 포인터 변수로 문자열의 시작주소를 가리키고 있음.
										// 문자열의 반환 타입은 애초에 const 타입
										// 문자열의 정보를 주소를 통해 얻어 읽기로만 사용해야지 직접 접근해서 수정하는 순간 코드 영역을 건드리는 것.

	szWChar[1] = 'z';
	// pChar[1] = 'z';	// *(pChar + 1)

	szWChar[0];		// 지역 스택 메모리 쪽으로 값을 복사 시켜온 배열의 첫번째 칸 'a'
	pChar[0];		// 주소 변수가 다이렉트로 그곳으로 주소를 통해 접근을 해서 주소를 받아와서 그곳의 첫번째 칸 'a'
					
	//pChar[0] = 'z';	// 수정되면 안됨.
						// 수정되는 상황이 발생하면 os 입장에서는 읽기전용 메모리인 코드 부분을 수정할려고 하기 때문에 문제가 발생!!
						// 컴파일 단계에서 문제를 잡아내지 못함!!

	short arrShort[10] = { 97, 98 ,99, 100, 101, 102, };	// 2바이트 정수


	// Multi-Byte Character Set, MBCS) : 문자에 따라 가변길이로 대응
	// 표준으로 사용하지는 않음.
	// 호환성 때문에 2바이트로 넘어갔다 인코딩해야함!
	// 문자가 나열되어 있을 때 메모리상에 1바이트 문자와 2바이트 문자가 섞여 있을 수도 있어서 비트까지 체크해야함.

	unsigned char szTest[10] = "abc한글";

	// Unicode(UTF - 8, UTF - 16)
	// 호환성이 좋음
	// 많은 언어를 표현할 수 있음
	wchar_t szTestW[10] = L"abc한글";

	return 0;
}