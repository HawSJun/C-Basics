# C-Cpp-Fundamentals
C와 C++ 기초

## 프로그래밍 언어 기초 다지기 전에....

### C언어 동작 원리

- 전처리 -> 컴파일 -> 어셈블 -> 링크, 이 네가지 과정을 **Build** 라고 함

    ```
    .c --(전처리)--> .i --(컴파일)--> .s --(어셈블)--> .o --(링크)--> .exe
    ```

<img src="./image/c004.png" width="600">

- **전처리 단계(Preprocess)**
    - 전처리기를 통해서 전처리문자(#include 등)들이 전처리 과정을 통해 해당 파일의 코드로 변환 **(.i)**

- **컴파일 과정(Compile)**
    - 컴파일러를 통해 컴파일이 되면 고급언어인 코드들이 `저급언어`인 어셈블리어로 변환 **(.s)**

- **어셈블 과정(Assemle)**
    - 어셈블러를 통해서 컴퓨터가 이해할 수 있는 `기계어`로 변환 되면서 파일이 생성 **(.o 또는 .obj)**

- **링크 과정(Link)**
    - 여러 개의 오브젝트 파일과 라이브러리를 결합하여 하나의 `실행파일(.exe)`을 생성하는 과정


### 자료형(Data Type) : [C/C++](./CBasics/data_type.cpp)

- 변수를 선언할 때 어떠한 자료의 형태를 나태내는지 설명하는 것
- 변수를 선언할 때 사용, 변수의 크기와 형태를 결정

<img src="./image/c007.png" width="600">

- 비트와 바이트

    ```
    1 byte = 8bits
    ```
    - 비트(bit): 정보의 최소 단위로, 0 또는 1을 표현
    - 바이트(byte): 8비트로 구성된 정보 단위로, 하나의 문자나 작은 범위의 정수를 표현

    <img src= "./image/c001.png" width="600">

    - MSB(Most Significant Bit)
        - 왼쪽 끝에 위치한 최상위 비트, 부호 비트로 양수(0)/음수(1) 

    - LSB(Least Significant Bit)
        - 오른쪽 끝에 위치한 비트

    ```
    unsigned cahr c = 0;
    ```
    - 1바이트의 크기 unsigned cahr 변수 선언하고 0으로 초기화
    - unsigned는 양수만 표현하기 때문에 `0 ~ 255` 표현

    ```
    c = 256;
    ```
    - 만약, `c = 256` 이면 
    - char는 1바이트의 크기 0 ~ 255 사이의 값만 표현하기 때문에 `1 0000 0000` 9bit가 되므로 0으로 표현됨

     <img src= "./image/c002.png" width="600">


#### 정수형 자료형 : [C/C++](./CBasics/data_type.cpp)

- unsigned (부호 없는)
    - 부호 없는 1바이트 정수형 0 ~ 255 표현

    ```
	unsigned char c = 0;
	c = 255; 
	c = -1;    // -1은 2의 보수로 인해 255로 표현
    ```

- signed (부호 있는)
    - 1바이트 양수, 음수 둘다 표현
	- -128 ~ 0 ~ 127, 음수, 양수를 다 표한하기 떄문에 최상위 비트를 부호비트로 사용

    ```
	char c1 = 0;
    c1 = 255        // 255를 넣었는데 -1로 표현됨
	c1 = -1; 
    ```

##### 2의 보수
- 양수는 이진수 그대로 표현
- 음수는 해당 양수의 이진수에서 모든 비트를 반전시키고, 그 결과에 1을 더한 값이 됨
    ```
    1101 0101 2의 보수 -> 비트 반전 -> 0010 1010 -> 마지막 비트에 1을 더함 - > 0010 1011
    ```

#### 실수형 자료형 : [C/C++](./CBasics/data_type.cpp)

- 정수와 실수는 메모리를 다루는 방식 자체가 다르다.(표현 방식이 다르다.)
- 특정 비트값이 정확하게 정해져있는 정수와는 달리 실수 표현방식은 `정밀도`에 의존한다
    - 여기서 정밀도란?
        - 컴퓨터는 실수를 유한한 비트 수로 표현하기 때문에, 모든 실수를 정확하게 저장할 수 없다. 
          따라서, 실수를 표현할 때 근사값으로 저장되며, 이 근사값이 실제 값과 얼마나 일치하는지의 정도를 정밀도라고 함.

- 부동 소수점
    - 소수점의 위치가 고정되지 않고 부동하는 방식

    <img src="./image/c006.png" width="800">

    - 부호 비트 (1bit) : 처음 1bit는 숫자가 양수인지 음수인지를 나타냄. 0은 양수, 1은 음수를 나타낸다.
    - 지수 부분(8bit) : 실수의 유효 숫자를 나타내며, 소수점 이하의 값. 부동 소수점에서는 첫 번째 비트가 항상 1로 고정되고, 이를 숨겨진 비트라고 부른다.
    - 가수 부분(23bit)  : 가수에 소수점의 위치를 지정하는 역할. 이 값은 실수의 크기를 조정하고, 부동 소수점에서 숫자의 범위를 확장하는 데 사용.

    - 10진수 13.25를 부동 소수점으로 변환
        ```
        부호 비트 : 0 (양수)
        지수 부분 : 13 = 0000 1101
        가수 부분 : 0.25 = 01         // 2^-1(0.5), 2^-2(0.25), 2^-3(0.0125)....
        13.25를 부동소수점 변환 : 1101.01
        부동소수점 정규화 : 1.10101 × 2^3 (가수 x 밑수^지수)
        ```
    - 정규화 : 가수의 첫번째 자리가 밑수보다 작은 한자리 자연수로 바꾸는 것을 의미

### 연산자 : [연산자1](./CBasics/operator.cpp) / [연산자2](./Day2/operator.c)

<img src="/image/c005.png" width="900">

- 산술 연산자 : [연산자](./CBasics/operator.cpp)
    - 종류 : +, -, *, /, %

    ```
    int data = 10 + 10;     // data에 20 저장
    data = data = 20;       // data += 20;  같은 의미

    data = 10 % 3;          // % (모듈러스, 나머지 연산자) : 피연산자가 모두 정수인 경우 사용

    실수를 상수로 표현할 경우 소수점 뒤에 f 를 붙이면 float 자료형으로, f 를 붙이지 않으면 double 자료형으로 인식한다. (0.1f, 0.1; // float, double)
    ```

- 증감 연산자 : [연산자](./CBasics/operator.cpp)
    - 종류 : ++, --

    ```
    ++data;     // 전위 증감
    data++;     // 후위 증감

    전위 연산자는 우선적으로 수행되며, 후위 연산자는 다른 연산이 먼저 수행된 후에 실행된다.

    data = 0;

	a = 10;
	data = ++a;     // data = 11, a = 11
	data = a++;     // data = 10, a = 11

	전위 증감과 후위 증감 상관없이 변수 공간 자체의 값이 실제로 증가함. 
    ```

- 논리 연산자 : [연산자](./CBasics/operator.cpp)
    - 종류 : !(NOT), &&(AND), ||(합)
        - ||(OR) : 두 피연산자 중 하나라도 참이면 참을 반환. 둘 다 거짓일 때만 거짓을 반환
    - `bool 자료형` : 참과 거짓을 표현하는 논리 자료형, 1바이트 크기를 가지며, 0과 1만을 저장할 수 있습니다.

    ```
    int truefalse = false;
	bool IsTrue = 100;          // bool : true, false

    참(Ture), 거짓(False)
	참   : 0 이외의 모든 값, 주로 1
	거짓 : 0
    ```

- 비교 연산자 : [연산자](./CBasics/operator.cpp)
    - 종류 : =, !=, <, <=, >, >=

- 삼항 연산자
    
    - if - else 문으로 간단하게 표현 가능

    ```
    조건식 ? 참일 때 값 : 거짓일 때 값;

    iTest == 20 ? iTest = 100 : iTest = 200;
    ```

- 비트 연산자 : [연산자1](./CBasics/conditional.cpp) / [연산자2](./Day2/shift.c)
    - 종류 : 쉬프트 연산자 (<<, >>), 비트 논리 연산자 ( &(AND), |(OR), ^(XOR), ~(NOT) )
        - ^(XOR) : 같으면 0, 다르면 1
    ```
    unsigned char byte = 1;

	byte <<= 3; // 2^n 배수

	byte >>= 1; // 2^n 나눈 몫

    좌측으로 이동 시 맨 오른쪽에 있는 비트는 0으로 채워짐

	우측으로 이동하면 맨 왼쪽에 있는 비트는 부호에 따라 비트가 달라짐
    (음수일 경우 1로 채워지고, 양수일 경우 0으로 채워짐)
    ```

### 조건문

- if / else : [조건문](./CBasics/if_else.cpp)
    
    ```
    if ( 조건식 )
    {
        // if 가 참인 경우 수행
    }
    else if ( 다른 조건식 )
    {
        // if 가 거짓이고 else if가 참이면 수행
    }
    else 
    {
        // if, else if 가 다 거짓이면 실행
    }
    ```

- switch-case : [조건문](./CBasics/switch_case.cpp)

    - 정수형 변수만 사용 가능 (float 불가능)
    - 비교 연산 (>, <, &&, ||) 사용 불가 
    - switch-case 문을 if-else 문으로 변경 가능
 
    ```
    int iTest = 20;

    switch (iTest)
    {
    case 10:
        // iTest가 10일 경우 실행
        break;
    case 20:
        // iTest가 20일 경우 실행
        break;
    default:
        // 일치하지 않으면 실행
        break;
    }
    ```

### 전차리기 #define : [전처리기](./CBasics/conditional.cpp)

- 전처리기 지시문으로, 특정 기호나 값을 매크로로 정의하는 역할
- 이를 통해 코드 내에서 특정한 값을 일괄적으로 치환하거나, 간단한 매크로 함수를 정의할 수 있습니다.
 ```
#define HUNGRY 1

unsigned int iStatus = HUNGRY;       // iStatus의 값은 1이다.
```

-  define 사용으로 인한 이점
    - 코드의 가독성을 높일 수 있다.
    - 코드의 유지보수를 쉽게 할 수 있다.
        - 일일이 수정할 필요 없이 #define에서만 값을 변경하면 일괄 적용

### 변수(Variable) : [변수](./CBasics/variable.cpp)